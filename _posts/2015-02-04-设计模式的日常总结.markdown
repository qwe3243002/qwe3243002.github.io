---
layout: post
title:  "设计模式总结"
date:   2015-02-04 22:36:30
categories: jekyll update
---

# 设计模式（未完待续）

## 设计模式原则


### 单一职责原则

解释：就一个类而言，应该仅有一个引起他变化的原因

原因：如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或抑制这个类完成其他职责的能力。这种耦合会导致设计的脆弱，当变化发生时，设计会遭受到意想不到的破坏。

### 开放封闭原则

解释：软件实体(类、模块、函数等),应该可以拓展,但不可修改。

原因：无论模块是多么封闭，都会存在一些无法对之封闭的变化。既然不能完全封闭，设计人员必须对于他设计的模块对于哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离这些变化。

### 依赖倒转原则

解释：
	
	A.高层模块不应该依赖底层模块。两个都应该依赖抽象。
	
	B.抽象不应该依赖细节。细节应该依赖抽象。


### 里氏替换原则


解释：一个软件实体如果使用的是一个父类的话，那么一定适用其子类，而且他察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成他的子类，程序的行为没有变化。

原因：由于子类的可替代性才使得使用父类类型的模块在无需修改的情况下就可以拓展。

### 迪米特法则

解释：如果两个类不必彼此直接通信，那么这两个类就不必发生直接的相互作用。如果其中一个类需要调用另一个类的某个方法的，可以通过第三者转发这
个调用。

原因：强调类之间的松耦合。类之间的耦合越弱，越有利于复用。一个处在弱耦合的类被修改，不会对有关系的类造成波及。

## 一、创建型模式

### 单例模式

解释：保证一个类仅有一个实例，并提供一个访问他的全局访问点。
使用：

	饿汉式：在加载时就将自己实例化。
	懒汉式：在第一次引用自己时，才将自己实例化。


### 简单工厂模式

解释：对于某一类行为提供统一方法来完成相应具体行为的实例化。

不好：虽然提供的统一方法来完成实例化相应对象，但一旦需要添加新的行为需要修改源码，破坏开放封闭原则。

### 工厂方法模式

解释：定义一个用于创建对象的接口，让子类决定实例化哪个类。使一个类的实例化延迟到子类。

原因：克服了简单工厂违背开放封闭原则的缺点，又保持了封装对象创建对象的优点。

### 抽象工厂模式

解释：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。

原因：
	
	1.便于交换产品系列，由于具体工厂类，在一个应用中只需要在初始化的时候出现一次，
	这就使得改变一个应用的具体工厂十分容易，只需要改变具体工厂就可以使用不同的产品配置。
	2.他让具体的创建实例的过程与客户端分离，客户端是通过他们的抽象接口操纵实例，
	产品的具体类名也被具体工厂的实现分离，不会出现在客户端的代码中


注意：通过反射、配置文件、简单工厂的方式能再次改进该模式。

### 建造者模式

解释：将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。

原因：创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方法。

### 原型模式

解释：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

原因：一般在初始化信息不发生变化的前提下，克隆是最好的办法，这既隐藏了对象创建的细节，又对性能是大大提高。

注意：克隆对象是涉及深复制和浅复制

### 总结：

创建型模式隐藏了这些类的实例是如何被创建和放在一起的，整个系统关于这于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建他、他是怎么被创建的、以及何时创建提供了很大的灵活性。

通常设计是从工厂方法开始，当设计者需要更大的灵活性时，设计便会向其他创建型模式演化。


## 二、结构型模式

### 适配器模式

解释：将一个类的接口转换成客户希望的另外一个接口，使得原来由于接口不兼容而不能一起工作的那些类可以一起工作。

原因：想使用原有的类，但如果他的接口或者方法与要求不同时，就该考虑适配器模式，这样可以更简单、更直接、更紧凑。

### 桥接模式

解释：将抽象部分与他的实现部分相分离，使他们能独立的变化。

原因：实现系统可能有多角度分类，每一种分类都可能变化，那么就把这种多角度分离出来让他们独立变化，减少他们之间的耦合。

### 组合模式

解释：将对象组合成树形结构，以表示部分-整体的层次结构，使得单个对象和组合对象的使用具有一致性。

原因：基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断的递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象了。

### 装饰模式

解释：动态地给对象添加一些额外的职责，就增加功能而言，比生成子类更加灵活。

原因：在系统设计时，在涉及新功能时会在主类中添加新的方法和逻辑，而这些新的东西只会在某些特定情况下才会执行。装饰模式，会把每个要装饰的功能放在单独的类中，并让这个类装饰他所要装饰的对象。这样客户端就可以有选择地按顺序装饰对象。这样有效地把类的核心职责和装饰功能区分开。

### 外观模式

解释：为子系统的一组接口提供一致的界面，通过定义一个高层接口，使得子系统更加容易使用。

原因：在设计初期阶段，有意识的将不同层分离开，在曾与层之间建立外观，能大大降低耦合。
在开发阶段，随着子系统不断重构演化会越加复杂，增加外观提供简单地接口能减少他们之间的依赖。
在维护遗留大型系统时，开发外观能在与新系统交互时，更加简单便捷。

### 享元模式

解释：运用共享技术有效地支持大量细粒度的对象。

原因：程序使用了大量对象，就会造成很大开销，通过移植参数及共享就可以大幅度减少对象数目。

### 代理模式

解释：为其他对象提供一种代理以控制对这个对象的访问。

原因：可以隐藏远程对象的地址空间，通过创建虚拟代理来存放实例化需要很长时间的真实对象，还可以控制对象的访问权限，及在调用真是对象时能处理一些事情。

## 三、行为型模式一组

### 观察者模式
解释：定义一种一对多的依赖关系，让多个观察者对象同时监听某一主体对象。在这个主题对象状态发生变化时，或通知所有观察者对象，使他们能够自动更新自己。

原因：在一个抽象模型中，有两个方面，其中一个方面依赖于另一个方面，这是用观察者模式可以将这两者封装在独立的对象中使他们各自独立地改变和复用。

改进：事件委托模式

### 模板方法模式

解释：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。

原因：使得子类可以不改变一个算法的结构既可以重定义该算法的步骤。

### 命令模式

解释：将一个请求封装成一个对象，从而可用不同的请求对客户进行参数化。

作用：

	1. 能比较容易的实现一个命令队列。
	2. 在需要的情况下，可以比较容易地将命令计入日志
	3. 允许接受请求的一方决定是否要否决该请求
	4. 可以容易地实现请求的撤消和重做
	5. 由于加入新的具体命令不影响其他类，因此容易增加新的命令类

### 状态模式

解释：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。

好处：将特定状态相关的行为局部化，并且不同状态的行为分割开来，

### 职责链模式

解释：使得多个对象都以机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递请求，直到有一个对象处理该请求。

好处：使得接受者和发送者都没有对方的明确信息，且链中的对象也不知道链的结构。结果是简化对象的相互链接。

## 四、行为型模式二组

### 解释器模式

解释：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

好处：可以很容易地改变和拓展文法。

### 中介者模式

解释：用一个中介对象来封装一系列对象的交互，使得一系列对象不用相互引用，从而降低之间的耦合。

### 访问者模式

解释：表示一个作用于某对象结构中的各元素的操作。它使得你可以在不改变各元素类的前提下定义作用与这些新元素的操作。

好处：适用与数据结构相对稳定的系统，将数据结构和作用于数据结构上的操作解耦。

### 策略模式

解释：定义算法家族，并分别封装起来，让他们之间能相互替换，而不影响到使用算法的用户。

### 备忘录模式

解释：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

### 迭代器模式

解释：提供一个方法顺序访问一个聚合对象中各个元素，而不暴露该对象的内部表示。
